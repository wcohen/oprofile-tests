# op_util.exp
#   Copyright (C) 2012 IBM
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

# globals which might change, perhaps?
set op_proc_prefix "/dev/oprofile"
set op_var_prefix "/var/lib/oprofile"

proc operf_get_proc_name {string} {
    # ophelp returns the processor name as a series of space separated
    # names.  Read string and replace spaces with underscores to match
    # the format expected in the operf_cpu_type{} switch statement
    set res ""
    set len [llength $string]
    set i 0

    foreach field $string {
	set res $res$field
	incr i

	if {$i != $len} {
	    set res $res\_
	}
    }
    return $res
}

# detect CPU type
proc operf_cpu_type {} {
    global op_proc_prefix

    set ophelp_result [ local_exec "ophelp -r" "" "" 100 ]
    set cpu_name [operf_get_proc_name [ lindex $ophelp_result 1 ]]
    
    set cpu_events [select_cpu_events $cpu_name]

# Note, operf does not support the timer modes

    switch -exact "$cpu_name" {
	4 {set cpu_events bogus}
	timer {set cpu_events bogus}
	5 {set cpu_events bogus}
	rtc {set cpu_events bogus}
    }

    return $cpu_events
}

proc operf_delete_samples {} {
    set result [local_exec "rm -rf ./oprofile_data" "" "" 100 ]
    if { [lindex $result 0] == 0 } {
	verbose "Successfully deleted exiting data directory"
    } else {
	verbose "Failed to delete exiting data directory"
    }
}

proc operf_check_samples_exist {ctrs} {
    set test "nonzero-sized sample file creation"

    verbose "checking for nonzero sample files"

    foreach ctr $ctrs {
	set n [lindex $ctr 0]
	set event [lindex $ctr 1]

	verbose "running opreport --symbols --long-filenames event:$event"
	set result [ local_exec "opreport --symbols --long-filenames event:$event" "" "" 100 ]
	if { [regexp "error:" "$result" ]} {
	    fail "$test: {$event} created nonzero sample files"
	} else {
	    pass "$test: {$event} created nonzero sample files"
	}
    }
}


proc operf_get_version {} {
    global operf_version

    set test "OProfile operf version check"
    verbose $test
    set result [ local_exec "operf -v" "" "" 100 ]


    if {[regexp "\[0-9\]+\(.\[0-9\]+\)+\[a-zA-Z_\]*" $result operf_version] == 1} {

#	Need to make sure the kernel has operf support as well
	if {[lindex [local_exec op-check-perfevents "" "" 100] 0] == 0} {
	    pass $test
	} else {
	    verbose "Kernel does not support operf\n"
	    set operf_version 0
	}
    } else {
	verbose "unable to determine version"
	set operf_version 0
	warning $test
    }
}
